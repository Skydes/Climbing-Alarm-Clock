 /***************************************************************************************
 *
 * Copyright (c) 2017, Paul-Edouard Sarlin
 * All rights reserved.
 *
 * Title:       Climbing Alarm Clock Project
 * File:        Module_Buzzer.cpp
 * Date:        2017-01-09
 * Author:      Paul-Edouard Sarlin
 * Website:     https://github.com/Skydes/Climbing-Alarm-Clock
 *
 ***************************************************************************************/

#include "Module_Buzzer.h"
#include <avr/pgmspace.h>

#define SONG_BUFFER 500
#define OCTAVE_OFFSET -1
#define isdigit(n) (n >= '0' && n <= '9')

char* song_setup(char *p);

int notes[] = { 0,
262, 277, 294, 311, 330, 349, 370, 392, 415, 440, 466, 494,
523, 554, 587, 622, 659, 698, 740, 784, 831, 880, 932, 988,
1047, 1109, 1175, 1245, 1319, 1397, 1480, 1568, 1661, 1760, 1865, 1976,
2093, 2217, 2349, 2489, 2637, 2794, 2960, 3136, 3322, 3520, 3729, 3951
};

byte default_dur;
byte default_oct;
int bpm;
int num;
long wholenote;
long duration;
byte note;
byte scale;

const char song_Mario[] PROGMEM = "Mario:d=4,o=5,b=100:16e6,16e6,32p,8e6,16c6,8e6,8g6,8p,8g,8p,8c6,16p,8g,16p,8e,16p,8a,8b,16a#,8a,16g.,16e6,16g6,8a6,16f6,8g6,8e6,16c6,16d6,8b,16p,8c6,16p,8g,16p,8e,16p,8a,8b,16a#,8a,16g.,16e6,16g6,8a6,16f6,8g6,8e6,16c6,16d6,8b,8p,16g6,16f#6,16f6,16d#6,16p,16e6,16p,16g#,16a,16c6,16p,16a,16c6,16d6,8p,16g6,16f#6,16f6,16d#6,16p,16e6,16p,16c7,16p,16c7,16c7,p,16g6,16f#6,16f6,16d#6,16p,16e6,16p,16g#,16a,16c6,16p,16a,16c6,16d6,8p,16d#6,8p,16d6,8p,16c6";
const char song_SW_main[] PROGMEM = "SW_main:d=4,o=5,b=45:32p,32f#,32f#,32f#,8b.,8f#.6,32e6,32d#6,32c#6,8b.6,16f#.6,32e6,32d#6,32c#6,8b.6,16f#.6,32e6,32d#6,32e6,8c#.6,32f#,32f#,32f#,8b.,8f#.6,32e6,32d#6,32c#6,8b.6,16f#.6,32e6,32d#6,32c#6,8b.6,16f#.6,32e6,32d#6,32e6,8c#6";
const char song_SW_cantina[] PROGMEM = "SW_cantina:d=4,o=5,b=250:8a,8p,8d6,8p,8a,8p,8d6,8p,8a,8d6,8p,8a,8p,8g#,a,8a,8g#,  8a,g,8f#,8g,8f#,f.,8d.,16p,p.,8a,8p,8d6,8p,8a,8p,8d6,8p,8a,8d6,8p,8a,8p,8g#,8a,8p, 8g,8p,g.,8f#,8g,8p,8c6,a#,a,g";
//char *song_SW_end = "SW_end:d=4,o=5,b=225:2c,1f,2g.,8g#,8a#,1g#,2c.,c,2f.,g,g#,c,8g#.,8c.,8c6,1a#.,2c,2f.,g,g#.,8f,c.6,8g#,1f6,2f,8g#.,8g.,8f,2c6,8c.6,8g#.,8f,2c,8c.,8c.,8c,2f,8f.,8f.,8f,2f";
//char *song_Zelda = "Zelda:d=4,o=5,b=125:a#,f.,8a#,16a#,16c6,16d6,16d#6,2f6,8p,8f6,16f.6,16f#6,16g#.6,2a#.6,16a#.6,16g#6,16f#.6,8g#.6,16f#.6,2f6,f6,8d#6,16d#6,16f6,2f#6,8f6,8d#6,8c#6,16c#6,16d#6,2f6,8d#6,8c#6,8c6,16c6,16d6,2e6,g6,8f6,16f,16f,8f,16f,16f,8f,16f,16f,8f,8f,a#,f.,8a#,16a#,16c6,16d6,16d#6,2f6,8p,8f6,16f.6,16f#6,16g#.6,2a#.6,c#7,c7,2a6,f6,2f#.6,a#6,a6,2f6,f6,2f#.6,a#6,a6,2f6,d6,2d#.6,f#6,f6,2c#6,a#,c6,16d6,2e6,g6,8f6,16f,16f,8f,16f,16f,8f,16f,16f,8f,8f";
//char *song_Bond = "Bond:d=4,o=5,b=80:32p,16c#6,32d#6,32d#6,16d#6,8d#6,16c#6,16c#6,16c#6,16c#6,32e6,32e6,16e6,8e6,16d#6,16d#6,16d#6,16c#6,32d#6,32d#6,16d#6,8d#6,16c#6,16c#6,16c#6,16c#6,32e6,32e6,16e6,8e6,16d#6,16d6,16c#6,16c#7,c.7,16g#6,16f#6,g#.6";

const char *songs[SONGS_NUMBER] = {song_Mario, song_SW_main, song_SW_cantina}; //, song_Zelda, song_Bond};
volatile uint8_t song_current = 0;
volatile bool stop_song_flag = false;

void Buzzer_set_ringtone(uint8_t new_ringtone)
{
  song_current = new_ringtone;
}

char* song_setup(char *p)
{
  while(*p != ':') p++;    // ignore name
  p++;                     // skip ':'
  
  if(*p == 'd') // get default duration
  {
    p++; p++;              // skip "d="
    num = 0;
    while(isdigit(*p))
    {
      num = (num * 10) + (*p++ - '0');
    }
    if(num > 0) default_dur = num;
    p++;                   // skip comma
  }
  
  if(*p == 'o') // get default octave
  {
    p++; p++;              // skip "o="
    num = *p++ - '0';
    if(num >= 3 && num <=7) default_oct = num;
    p++;                   // skip comma
  }
 
  if(*p == 'b') // get BPM
  {
    p++; p++;              // skip "b="
    num = 0;
    while(isdigit(*p))
    {
      num = (num * 10) + (*p++ - '0');
    }
    bpm = num;
    p++;                   // skip colon
  }
 
  wholenote = (60 * 1000L / bpm) * 4;  // this is the time for whole note (in milliseconds)

  return p;
}

bool Buzzer_play()
{
  default_dur = 4, default_oct = 6, bpm = 63;
  char song[SONG_BUFFER];
  strcpy_P(song, songs[song_current]);
  char *p = (char*) song;
  p = song_setup(p);
  
  while(*p)
  {
    num = 0;
    while(isdigit(*p)) // first, get note duration, if available
    {
      num = (num * 10) + (*p++ - '0');
    }
    
    if(num) duration = wholenote / num;
    else duration = wholenote / default_dur;  // we will need to check if we are a dotted note after
 
    note = 0; // now get the note
    switch(*p)
    {
      case 'c':
        note = 1;
        break;
      case 'd':
        note = 3;
        break;
      case 'e':
        note = 5;
        break;
      case 'f':
        note = 6;
        break;
      case 'g':
        note = 8;
        break;
      case 'a':
        note = 10;
        break;
      case 'b':
        note = 12;
        break;
      case 'p':
      default:
        note = 0;
    }
    p++;
 
    if(*p == '#') // now, get optional '#' sharp
    {
      note++;
      p++;
    }
 
    if(*p == '.') // now, get optional '.' dotted note
    {
      duration += duration/2;
      p++;
    }
  
    if(isdigit(*p)) // now, get scale
    {
      scale = *p - '0';
      p++;
    }
    else
    {
      scale = default_oct;
    }
 
    scale += OCTAVE_OFFSET;
 
    if(*p == ',')
      p++;       // skip comma for next note (or we may be at the end)
 
    if(note) // now play the note
    {
      tone(BUZZER, notes[(scale - 4) * 12 + note]);
      delay(duration);
      noTone(BUZZER);
    }
    else
      delay(duration);

    if(stop_song_flag || (global_state != S_RINGING))
      return false;
  }
  return true;
}

